// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  cart: (where?: CartWhereInput) => Promise<boolean>;
  failedJob: (where?: FailedJobWhereInput) => Promise<boolean>;
  favorite: (where?: FavoriteWhereInput) => Promise<boolean>;
  migration: (where?: MigrationWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  ordernotif: (where?: OrdernotifWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  token: (where?: TokenWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  viewnotif: (where?: ViewnotifWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cart: (where: CartWhereUniqueInput) => CartPromise;
  carts: (
    args?: {
      where?: CartWhereInput;
      orderBy?: CartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cart>;
  cartsConnection: (
    args?: {
      where?: CartWhereInput;
      orderBy?: CartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CartConnectionPromise;
  failedJob: (where: FailedJobWhereUniqueInput) => FailedJobPromise;
  failedJobs: (
    args?: {
      where?: FailedJobWhereInput;
      orderBy?: FailedJobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FailedJob>;
  failedJobsConnection: (
    args?: {
      where?: FailedJobWhereInput;
      orderBy?: FailedJobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FailedJobConnectionPromise;
  favorite: (where: FavoriteWhereUniqueInput) => FavoritePromise;
  favorites: (
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Favorite>;
  favoritesConnection: (
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FavoriteConnectionPromise;
  migration: (where: MigrationWhereUniqueInput) => MigrationPromise;
  migrations: (
    args?: {
      where?: MigrationWhereInput;
      orderBy?: MigrationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Migration>;
  migrationsConnection: (
    args?: {
      where?: MigrationWhereInput;
      orderBy?: MigrationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MigrationConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Order>;
  ordersConnection: (
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrderConnectionPromise;
  ordernotif: (where: OrdernotifWhereUniqueInput) => OrdernotifPromise;
  ordernotifs: (
    args?: {
      where?: OrdernotifWhereInput;
      orderBy?: OrdernotifOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Ordernotif>;
  ordernotifsConnection: (
    args?: {
      where?: OrdernotifWhereInput;
      orderBy?: OrdernotifOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrdernotifConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectPromise;
  projects: (
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Project>;
  projectsConnection: (
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectConnectionPromise;
  token: (where: TokenWhereUniqueInput) => TokenPromise;
  tokens: (
    args?: {
      where?: TokenWhereInput;
      orderBy?: TokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Token>;
  tokensConnection: (
    args?: {
      where?: TokenWhereInput;
      orderBy?: TokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TokenConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  viewnotif: (where: ViewnotifWhereUniqueInput) => ViewnotifPromise;
  viewnotifs: (
    args?: {
      where?: ViewnotifWhereInput;
      orderBy?: ViewnotifOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Viewnotif>;
  viewnotifsConnection: (
    args?: {
      where?: ViewnotifWhereInput;
      orderBy?: ViewnotifOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ViewnotifConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCart: (data: CartCreateInput) => CartPromise;
  updateCart: (
    args: { data: CartUpdateInput; where: CartWhereUniqueInput }
  ) => CartPromise;
  updateManyCarts: (
    args: { data: CartUpdateManyMutationInput; where?: CartWhereInput }
  ) => BatchPayloadPromise;
  upsertCart: (
    args: {
      where: CartWhereUniqueInput;
      create: CartCreateInput;
      update: CartUpdateInput;
    }
  ) => CartPromise;
  deleteCart: (where: CartWhereUniqueInput) => CartPromise;
  deleteManyCarts: (where?: CartWhereInput) => BatchPayloadPromise;
  createFailedJob: (data: FailedJobCreateInput) => FailedJobPromise;
  updateFailedJob: (
    args: { data: FailedJobUpdateInput; where: FailedJobWhereUniqueInput }
  ) => FailedJobPromise;
  updateManyFailedJobs: (
    args: {
      data: FailedJobUpdateManyMutationInput;
      where?: FailedJobWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFailedJob: (
    args: {
      where: FailedJobWhereUniqueInput;
      create: FailedJobCreateInput;
      update: FailedJobUpdateInput;
    }
  ) => FailedJobPromise;
  deleteFailedJob: (where: FailedJobWhereUniqueInput) => FailedJobPromise;
  deleteManyFailedJobs: (where?: FailedJobWhereInput) => BatchPayloadPromise;
  createFavorite: (data: FavoriteCreateInput) => FavoritePromise;
  updateFavorite: (
    args: { data: FavoriteUpdateInput; where: FavoriteWhereUniqueInput }
  ) => FavoritePromise;
  updateManyFavorites: (
    args: { data: FavoriteUpdateManyMutationInput; where?: FavoriteWhereInput }
  ) => BatchPayloadPromise;
  upsertFavorite: (
    args: {
      where: FavoriteWhereUniqueInput;
      create: FavoriteCreateInput;
      update: FavoriteUpdateInput;
    }
  ) => FavoritePromise;
  deleteFavorite: (where: FavoriteWhereUniqueInput) => FavoritePromise;
  deleteManyFavorites: (where?: FavoriteWhereInput) => BatchPayloadPromise;
  createMigration: (data: MigrationCreateInput) => MigrationPromise;
  updateMigration: (
    args: { data: MigrationUpdateInput; where: MigrationWhereUniqueInput }
  ) => MigrationPromise;
  updateManyMigrations: (
    args: {
      data: MigrationUpdateManyMutationInput;
      where?: MigrationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMigration: (
    args: {
      where: MigrationWhereUniqueInput;
      create: MigrationCreateInput;
      update: MigrationUpdateInput;
    }
  ) => MigrationPromise;
  deleteMigration: (where: MigrationWhereUniqueInput) => MigrationPromise;
  deleteManyMigrations: (where?: MigrationWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (
    args: { data: OrderUpdateInput; where: OrderWhereUniqueInput }
  ) => OrderPromise;
  updateManyOrders: (
    args: { data: OrderUpdateManyMutationInput; where?: OrderWhereInput }
  ) => BatchPayloadPromise;
  upsertOrder: (
    args: {
      where: OrderWhereUniqueInput;
      create: OrderCreateInput;
      update: OrderUpdateInput;
    }
  ) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createOrdernotif: (data: OrdernotifCreateInput) => OrdernotifPromise;
  updateOrdernotif: (
    args: { data: OrdernotifUpdateInput; where: OrdernotifWhereUniqueInput }
  ) => OrdernotifPromise;
  updateManyOrdernotifs: (
    args: {
      data: OrdernotifUpdateManyMutationInput;
      where?: OrdernotifWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertOrdernotif: (
    args: {
      where: OrdernotifWhereUniqueInput;
      create: OrdernotifCreateInput;
      update: OrdernotifUpdateInput;
    }
  ) => OrdernotifPromise;
  deleteOrdernotif: (where: OrdernotifWhereUniqueInput) => OrdernotifPromise;
  deleteManyOrdernotifs: (where?: OrdernotifWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (
    args: { data: ProjectUpdateInput; where: ProjectWhereUniqueInput }
  ) => ProjectPromise;
  updateManyProjects: (
    args: { data: ProjectUpdateManyMutationInput; where?: ProjectWhereInput }
  ) => BatchPayloadPromise;
  upsertProject: (
    args: {
      where: ProjectWhereUniqueInput;
      create: ProjectCreateInput;
      update: ProjectUpdateInput;
    }
  ) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createToken: (data: TokenCreateInput) => TokenPromise;
  updateToken: (
    args: { data: TokenUpdateInput; where: TokenWhereUniqueInput }
  ) => TokenPromise;
  updateManyTokens: (
    args: { data: TokenUpdateManyMutationInput; where?: TokenWhereInput }
  ) => BatchPayloadPromise;
  upsertToken: (
    args: {
      where: TokenWhereUniqueInput;
      create: TokenCreateInput;
      update: TokenUpdateInput;
    }
  ) => TokenPromise;
  deleteToken: (where: TokenWhereUniqueInput) => TokenPromise;
  deleteManyTokens: (where?: TokenWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createViewnotif: (data: ViewnotifCreateInput) => ViewnotifPromise;
  updateViewnotif: (
    args: { data: ViewnotifUpdateInput; where: ViewnotifWhereUniqueInput }
  ) => ViewnotifPromise;
  updateManyViewnotifs: (
    args: {
      data: ViewnotifUpdateManyMutationInput;
      where?: ViewnotifWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertViewnotif: (
    args: {
      where: ViewnotifWhereUniqueInput;
      create: ViewnotifCreateInput;
      update: ViewnotifUpdateInput;
    }
  ) => ViewnotifPromise;
  deleteViewnotif: (where: ViewnotifWhereUniqueInput) => ViewnotifPromise;
  deleteManyViewnotifs: (where?: ViewnotifWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cart: (
    where?: CartSubscriptionWhereInput
  ) => CartSubscriptionPayloadSubscription;
  failedJob: (
    where?: FailedJobSubscriptionWhereInput
  ) => FailedJobSubscriptionPayloadSubscription;
  favorite: (
    where?: FavoriteSubscriptionWhereInput
  ) => FavoriteSubscriptionPayloadSubscription;
  migration: (
    where?: MigrationSubscriptionWhereInput
  ) => MigrationSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  ordernotif: (
    where?: OrdernotifSubscriptionWhereInput
  ) => OrdernotifSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  token: (
    where?: TokenSubscriptionWhereInput
  ) => TokenSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  viewnotif: (
    where?: ViewnotifSubscriptionWhereInput
  ) => ViewnotifSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "productid_ASC"
  | "productid_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "exclusive_ASC"
  | "exclusive_DESC"
  | "image_ASC"
  | "image_DESC"
  | "name_ASC"
  | "name_DESC"
  | "plusprice_ASC"
  | "plusprice_DESC"
  | "price_ASC"
  | "price_DESC"
  | "pricedrop_ASC"
  | "pricedrop_DESC"
  | "return_ASC"
  | "return_DESC"
  | "seller_ASC"
  | "seller_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mail_ASC"
  | "mail_DESC"
  | "productid_ASC"
  | "productid_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FailedJobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "connection_ASC"
  | "connection_DESC"
  | "exception_ASC"
  | "exception_DESC"
  | "failedAt_ASC"
  | "failedAt_DESC"
  | "payload_ASC"
  | "payload_DESC"
  | "queue_ASC"
  | "queue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "address_ASC"
  | "address_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "favorites_ASC"
  | "favorites_DESC"
  | "isadmin_ASC"
  | "isadmin_DESC"
  | "issuper_ASC"
  | "issuper_DESC"
  | "items_ASC"
  | "items_DESC"
  | "name_ASC"
  | "name_DESC"
  | "number_ASC"
  | "number_DESC"
  | "password_ASC"
  | "password_DESC"
  | "payment_ASC"
  | "payment_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "plus_ASC"
  | "plus_DESC"
  | "reqadmin_ASC"
  | "reqadmin_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FavoriteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "productid_ASC"
  | "productid_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MigrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "batch_ASC"
  | "batch_DESC"
  | "migration_ASC"
  | "migration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "feedback_ASC"
  | "feedback_DESC"
  | "productid_ASC"
  | "productid_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "remind_ASC"
  | "remind_DESC"
  | "return_ASC"
  | "return_DESC"
  | "status_ASC"
  | "status_DESC"
  | "transid_ASC"
  | "transid_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrdernotifOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "productid_ASC"
  | "productid_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "view_ASC"
  | "view_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type TokenOrderByInput =
  | "refresh_ASC"
  | "refresh_DESC"
  | "access_ASC"
  | "access_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type ViewnotifOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "productid_ASC"
  | "productid_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CartWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  productid?: String;
}>;

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  exclusive?: String;
  exclusive_not?: String;
  exclusive_in?: String[] | String;
  exclusive_not_in?: String[] | String;
  exclusive_lt?: String;
  exclusive_lte?: String;
  exclusive_gt?: String;
  exclusive_gte?: String;
  exclusive_contains?: String;
  exclusive_not_contains?: String;
  exclusive_starts_with?: String;
  exclusive_not_starts_with?: String;
  exclusive_ends_with?: String;
  exclusive_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  plusprice?: String;
  plusprice_not?: String;
  plusprice_in?: String[] | String;
  plusprice_not_in?: String[] | String;
  plusprice_lt?: String;
  plusprice_lte?: String;
  plusprice_gt?: String;
  plusprice_gte?: String;
  plusprice_contains?: String;
  plusprice_not_contains?: String;
  plusprice_starts_with?: String;
  plusprice_not_starts_with?: String;
  plusprice_ends_with?: String;
  plusprice_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  pricedrop?: String;
  pricedrop_not?: String;
  pricedrop_in?: String[] | String;
  pricedrop_not_in?: String[] | String;
  pricedrop_lt?: String;
  pricedrop_lte?: String;
  pricedrop_gt?: String;
  pricedrop_gte?: String;
  pricedrop_contains?: String;
  pricedrop_not_contains?: String;
  pricedrop_starts_with?: String;
  pricedrop_not_starts_with?: String;
  pricedrop_ends_with?: String;
  pricedrop_not_ends_with?: String;
  return?: String;
  return_not?: String;
  return_in?: String[] | String;
  return_not_in?: String[] | String;
  return_lt?: String;
  return_lte?: String;
  return_gt?: String;
  return_gte?: String;
  return_contains?: String;
  return_not_contains?: String;
  return_starts_with?: String;
  return_not_starts_with?: String;
  return_ends_with?: String;
  return_not_ends_with?: String;
  seller?: String;
  seller_not?: String;
  seller_in?: String[] | String;
  seller_not_in?: String[] | String;
  seller_lt?: String;
  seller_lte?: String;
  seller_gt?: String;
  seller_gte?: String;
  seller_contains?: String;
  seller_not_contains?: String;
  seller_starts_with?: String;
  seller_not_starts_with?: String;
  seller_ends_with?: String;
  seller_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userdetail_every?: CartWhereInput;
  userdetail_some?: CartWhereInput;
  userdetail_none?: CartWhereInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface CartWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mail?: String;
  mail_not?: String;
  mail_in?: String[] | String;
  mail_not_in?: String[] | String;
  mail_lt?: String;
  mail_lte?: String;
  mail_gt?: String;
  mail_gte?: String;
  mail_contains?: String;
  mail_not_contains?: String;
  mail_starts_with?: String;
  mail_not_starts_with?: String;
  mail_ends_with?: String;
  mail_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  productdetail_every?: ProductWhereInput;
  productdetail_some?: ProductWhereInput;
  productdetail_none?: ProductWhereInput;
  AND?: CartWhereInput[] | CartWhereInput;
  OR?: CartWhereInput[] | CartWhereInput;
  NOT?: CartWhereInput[] | CartWhereInput;
}

export type FailedJobWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FailedJobWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  connection?: String;
  connection_not?: String;
  connection_in?: String[] | String;
  connection_not_in?: String[] | String;
  connection_lt?: String;
  connection_lte?: String;
  connection_gt?: String;
  connection_gte?: String;
  connection_contains?: String;
  connection_not_contains?: String;
  connection_starts_with?: String;
  connection_not_starts_with?: String;
  connection_ends_with?: String;
  connection_not_ends_with?: String;
  exception?: String;
  exception_not?: String;
  exception_in?: String[] | String;
  exception_not_in?: String[] | String;
  exception_lt?: String;
  exception_lte?: String;
  exception_gt?: String;
  exception_gte?: String;
  exception_contains?: String;
  exception_not_contains?: String;
  exception_starts_with?: String;
  exception_not_starts_with?: String;
  exception_ends_with?: String;
  exception_not_ends_with?: String;
  failedAt?: DateTimeInput;
  failedAt_not?: DateTimeInput;
  failedAt_in?: DateTimeInput[] | DateTimeInput;
  failedAt_not_in?: DateTimeInput[] | DateTimeInput;
  failedAt_lt?: DateTimeInput;
  failedAt_lte?: DateTimeInput;
  failedAt_gt?: DateTimeInput;
  failedAt_gte?: DateTimeInput;
  payload?: String;
  payload_not?: String;
  payload_in?: String[] | String;
  payload_not_in?: String[] | String;
  payload_lt?: String;
  payload_lte?: String;
  payload_gt?: String;
  payload_gte?: String;
  payload_contains?: String;
  payload_not_contains?: String;
  payload_starts_with?: String;
  payload_not_starts_with?: String;
  payload_ends_with?: String;
  payload_not_ends_with?: String;
  queue?: String;
  queue_not?: String;
  queue_in?: String[] | String;
  queue_not_in?: String[] | String;
  queue_lt?: String;
  queue_lte?: String;
  queue_gt?: String;
  queue_gte?: String;
  queue_contains?: String;
  queue_not_contains?: String;
  queue_starts_with?: String;
  queue_not_starts_with?: String;
  queue_ends_with?: String;
  queue_not_ends_with?: String;
  AND?: FailedJobWhereInput[] | FailedJobWhereInput;
  OR?: FailedJobWhereInput[] | FailedJobWhereInput;
  NOT?: FailedJobWhereInput[] | FailedJobWhereInput;
}

export type FavoriteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  productid?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  isadmin?: String;
  isadmin_not?: String;
  isadmin_in?: String[] | String;
  isadmin_not_in?: String[] | String;
  isadmin_lt?: String;
  isadmin_lte?: String;
  isadmin_gt?: String;
  isadmin_gte?: String;
  isadmin_contains?: String;
  isadmin_not_contains?: String;
  isadmin_starts_with?: String;
  isadmin_not_starts_with?: String;
  isadmin_ends_with?: String;
  isadmin_not_ends_with?: String;
  issuper?: String;
  issuper_not?: String;
  issuper_in?: String[] | String;
  issuper_not_in?: String[] | String;
  issuper_lt?: String;
  issuper_lte?: String;
  issuper_gt?: String;
  issuper_gte?: String;
  issuper_contains?: String;
  issuper_not_contains?: String;
  issuper_starts_with?: String;
  issuper_not_starts_with?: String;
  issuper_ends_with?: String;
  issuper_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  payment?: String;
  payment_not?: String;
  payment_in?: String[] | String;
  payment_not_in?: String[] | String;
  payment_lt?: String;
  payment_lte?: String;
  payment_gt?: String;
  payment_gte?: String;
  payment_contains?: String;
  payment_not_contains?: String;
  payment_starts_with?: String;
  payment_not_starts_with?: String;
  payment_ends_with?: String;
  payment_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  plus?: String;
  plus_not?: String;
  plus_in?: String[] | String;
  plus_not_in?: String[] | String;
  plus_lt?: String;
  plus_lte?: String;
  plus_gt?: String;
  plus_gte?: String;
  plus_contains?: String;
  plus_not_contains?: String;
  plus_starts_with?: String;
  plus_not_starts_with?: String;
  plus_ends_with?: String;
  plus_not_ends_with?: String;
  reqadmin?: String;
  reqadmin_not?: String;
  reqadmin_in?: String[] | String;
  reqadmin_not_in?: String[] | String;
  reqadmin_lt?: String;
  reqadmin_lte?: String;
  reqadmin_gt?: String;
  reqadmin_gte?: String;
  reqadmin_contains?: String;
  reqadmin_not_contains?: String;
  reqadmin_starts_with?: String;
  reqadmin_not_starts_with?: String;
  reqadmin_ends_with?: String;
  reqadmin_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  favs_every?: FavoriteWhereInput;
  favs_some?: FavoriteWhereInput;
  favs_none?: FavoriteWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface FavoriteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owner_every?: UserWhereInput;
  owner_some?: UserWhereInput;
  owner_none?: UserWhereInput;
  productdetail_every?: ProductWhereInput;
  productdetail_some?: ProductWhereInput;
  productdetail_none?: ProductWhereInput;
  AND?: FavoriteWhereInput[] | FavoriteWhereInput;
  OR?: FavoriteWhereInput[] | FavoriteWhereInput;
  NOT?: FavoriteWhereInput[] | FavoriteWhereInput;
}

export type MigrationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MigrationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  batch?: Int;
  batch_not?: Int;
  batch_in?: Int[] | Int;
  batch_not_in?: Int[] | Int;
  batch_lt?: Int;
  batch_lte?: Int;
  batch_gt?: Int;
  batch_gte?: Int;
  migration?: String;
  migration_not?: String;
  migration_in?: String[] | String;
  migration_not_in?: String[] | String;
  migration_lt?: String;
  migration_lte?: String;
  migration_gt?: String;
  migration_gte?: String;
  migration_contains?: String;
  migration_not_contains?: String;
  migration_starts_with?: String;
  migration_not_starts_with?: String;
  migration_ends_with?: String;
  migration_not_ends_with?: String;
  AND?: MigrationWhereInput[] | MigrationWhereInput;
  OR?: MigrationWhereInput[] | MigrationWhereInput;
  NOT?: MigrationWhereInput[] | MigrationWhereInput;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  feedback?: String;
  feedback_not?: String;
  feedback_in?: String[] | String;
  feedback_not_in?: String[] | String;
  feedback_lt?: String;
  feedback_lte?: String;
  feedback_gt?: String;
  feedback_gte?: String;
  feedback_contains?: String;
  feedback_not_contains?: String;
  feedback_starts_with?: String;
  feedback_not_starts_with?: String;
  feedback_ends_with?: String;
  feedback_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  rating?: String;
  rating_not?: String;
  rating_in?: String[] | String;
  rating_not_in?: String[] | String;
  rating_lt?: String;
  rating_lte?: String;
  rating_gt?: String;
  rating_gte?: String;
  rating_contains?: String;
  rating_not_contains?: String;
  rating_starts_with?: String;
  rating_not_starts_with?: String;
  rating_ends_with?: String;
  rating_not_ends_with?: String;
  remind?: String;
  remind_not?: String;
  remind_in?: String[] | String;
  remind_not_in?: String[] | String;
  remind_lt?: String;
  remind_lte?: String;
  remind_gt?: String;
  remind_gte?: String;
  remind_contains?: String;
  remind_not_contains?: String;
  remind_starts_with?: String;
  remind_not_starts_with?: String;
  remind_ends_with?: String;
  remind_not_ends_with?: String;
  return?: String;
  return_not?: String;
  return_in?: String[] | String;
  return_not_in?: String[] | String;
  return_lt?: String;
  return_lte?: String;
  return_gt?: String;
  return_gte?: String;
  return_contains?: String;
  return_not_contains?: String;
  return_starts_with?: String;
  return_not_starts_with?: String;
  return_ends_with?: String;
  return_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  transid?: String;
  transid_not?: String;
  transid_in?: String[] | String;
  transid_not_in?: String[] | String;
  transid_lt?: String;
  transid_lte?: String;
  transid_gt?: String;
  transid_gte?: String;
  transid_contains?: String;
  transid_not_contains?: String;
  transid_starts_with?: String;
  transid_not_starts_with?: String;
  transid_ends_with?: String;
  transid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owner?: UserWhereInput;
  productdetail?: ProductWhereInput;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export type OrdernotifWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrdernotifWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  view?: String;
  view_not?: String;
  view_in?: String[] | String;
  view_not_in?: String[] | String;
  view_lt?: String;
  view_lte?: String;
  view_gt?: String;
  view_gte?: String;
  view_contains?: String;
  view_not_contains?: String;
  view_starts_with?: String;
  view_not_starts_with?: String;
  view_ends_with?: String;
  view_not_ends_with?: String;
  AND?: OrdernotifWhereInput[] | OrdernotifWhereInput;
  OR?: OrdernotifWhereInput[] | OrdernotifWhereInput;
  NOT?: OrdernotifWhereInput[] | OrdernotifWhereInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  productid?: String;
}>;

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProjectWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  AND?: ProjectWhereInput[] | ProjectWhereInput;
  OR?: ProjectWhereInput[] | ProjectWhereInput;
  NOT?: ProjectWhereInput[] | ProjectWhereInput;
}

export type TokenWhereUniqueInput = AtLeastOne<{
  refresh: ID_Input;
}>;

export interface TokenWhereInput {
  refresh?: ID_Input;
  refresh_not?: ID_Input;
  refresh_in?: ID_Input[] | ID_Input;
  refresh_not_in?: ID_Input[] | ID_Input;
  refresh_lt?: ID_Input;
  refresh_lte?: ID_Input;
  refresh_gt?: ID_Input;
  refresh_gte?: ID_Input;
  refresh_contains?: ID_Input;
  refresh_not_contains?: ID_Input;
  refresh_starts_with?: ID_Input;
  refresh_not_starts_with?: ID_Input;
  refresh_ends_with?: ID_Input;
  refresh_not_ends_with?: ID_Input;
  access?: String;
  access_not?: String;
  access_in?: String[] | String;
  access_not_in?: String[] | String;
  access_lt?: String;
  access_lte?: String;
  access_gt?: String;
  access_gte?: String;
  access_contains?: String;
  access_not_contains?: String;
  access_starts_with?: String;
  access_not_starts_with?: String;
  access_ends_with?: String;
  access_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TokenWhereInput[] | TokenWhereInput;
  OR?: TokenWhereInput[] | TokenWhereInput;
  NOT?: TokenWhereInput[] | TokenWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type ViewnotifWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ViewnotifWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ViewnotifWhereInput[] | ViewnotifWhereInput;
  OR?: ViewnotifWhereInput[] | ViewnotifWhereInput;
  NOT?: ViewnotifWhereInput[] | ViewnotifWhereInput;
}

export interface CartCreateInput {
  email: String;
  mail?: String;
  productid?: String;
  productdetail?: ProductCreateManyWithoutUserdetailInput;
}

export interface ProductCreateManyWithoutUserdetailInput {
  create?:
    | ProductCreateWithoutUserdetailInput[]
    | ProductCreateWithoutUserdetailInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateWithoutUserdetailInput {
  productid: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
}

export interface CartUpdateInput {
  email?: String;
  mail?: String;
  productid?: String;
  productdetail?: ProductUpdateManyWithoutUserdetailInput;
}

export interface ProductUpdateManyWithoutUserdetailInput {
  create?:
    | ProductCreateWithoutUserdetailInput[]
    | ProductCreateWithoutUserdetailInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutUserdetailInput[]
    | ProductUpdateWithWhereUniqueWithoutUserdetailInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutUserdetailInput[]
    | ProductUpsertWithWhereUniqueWithoutUserdetailInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateWithWhereUniqueWithoutUserdetailInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutUserdetailDataInput;
}

export interface ProductUpdateWithoutUserdetailDataInput {
  productid?: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
}

export interface ProductUpsertWithWhereUniqueWithoutUserdetailInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutUserdetailDataInput;
  create: ProductCreateWithoutUserdetailInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  exclusive?: String;
  exclusive_not?: String;
  exclusive_in?: String[] | String;
  exclusive_not_in?: String[] | String;
  exclusive_lt?: String;
  exclusive_lte?: String;
  exclusive_gt?: String;
  exclusive_gte?: String;
  exclusive_contains?: String;
  exclusive_not_contains?: String;
  exclusive_starts_with?: String;
  exclusive_not_starts_with?: String;
  exclusive_ends_with?: String;
  exclusive_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  plusprice?: String;
  plusprice_not?: String;
  plusprice_in?: String[] | String;
  plusprice_not_in?: String[] | String;
  plusprice_lt?: String;
  plusprice_lte?: String;
  plusprice_gt?: String;
  plusprice_gte?: String;
  plusprice_contains?: String;
  plusprice_not_contains?: String;
  plusprice_starts_with?: String;
  plusprice_not_starts_with?: String;
  plusprice_ends_with?: String;
  plusprice_not_ends_with?: String;
  price?: String;
  price_not?: String;
  price_in?: String[] | String;
  price_not_in?: String[] | String;
  price_lt?: String;
  price_lte?: String;
  price_gt?: String;
  price_gte?: String;
  price_contains?: String;
  price_not_contains?: String;
  price_starts_with?: String;
  price_not_starts_with?: String;
  price_ends_with?: String;
  price_not_ends_with?: String;
  pricedrop?: String;
  pricedrop_not?: String;
  pricedrop_in?: String[] | String;
  pricedrop_not_in?: String[] | String;
  pricedrop_lt?: String;
  pricedrop_lte?: String;
  pricedrop_gt?: String;
  pricedrop_gte?: String;
  pricedrop_contains?: String;
  pricedrop_not_contains?: String;
  pricedrop_starts_with?: String;
  pricedrop_not_starts_with?: String;
  pricedrop_ends_with?: String;
  pricedrop_not_ends_with?: String;
  return?: String;
  return_not?: String;
  return_in?: String[] | String;
  return_not_in?: String[] | String;
  return_lt?: String;
  return_lte?: String;
  return_gt?: String;
  return_gte?: String;
  return_contains?: String;
  return_not_contains?: String;
  return_starts_with?: String;
  return_not_starts_with?: String;
  return_ends_with?: String;
  return_not_ends_with?: String;
  seller?: String;
  seller_not?: String;
  seller_in?: String[] | String;
  seller_not_in?: String[] | String;
  seller_lt?: String;
  seller_lte?: String;
  seller_gt?: String;
  seller_gte?: String;
  seller_contains?: String;
  seller_not_contains?: String;
  seller_starts_with?: String;
  seller_not_starts_with?: String;
  seller_ends_with?: String;
  seller_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductUpdateManyDataInput {
  productid?: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
}

export interface CartUpdateManyMutationInput {
  email?: String;
  mail?: String;
  productid?: String;
}

export interface FailedJobCreateInput {
  connection: String;
  exception: String;
  failedAt: DateTimeInput;
  payload: String;
  queue: String;
}

export interface FailedJobUpdateInput {
  connection?: String;
  exception?: String;
  failedAt?: DateTimeInput;
  payload?: String;
  queue?: String;
}

export interface FailedJobUpdateManyMutationInput {
  connection?: String;
  exception?: String;
  failedAt?: DateTimeInput;
  payload?: String;
  queue?: String;
}

export interface FavoriteCreateInput {
  email?: String;
  productid?: String;
  owner?: UserCreateManyWithoutFavsInput;
  productdetail?: ProductCreateManyInput;
}

export interface UserCreateManyWithoutFavsInput {
  create?: UserCreateWithoutFavsInput[] | UserCreateWithoutFavsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutFavsInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
}

export interface ProductCreateManyInput {
  create?: ProductCreateInput[] | ProductCreateInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateInput {
  productid: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
  userdetail?: CartCreateManyWithoutProductdetailInput;
}

export interface CartCreateManyWithoutProductdetailInput {
  create?:
    | CartCreateWithoutProductdetailInput[]
    | CartCreateWithoutProductdetailInput;
  connect?: CartWhereUniqueInput[] | CartWhereUniqueInput;
}

export interface CartCreateWithoutProductdetailInput {
  email: String;
  mail?: String;
  productid?: String;
}

export interface FavoriteUpdateInput {
  email?: String;
  productid?: String;
  owner?: UserUpdateManyWithoutFavsInput;
  productdetail?: ProductUpdateManyInput;
}

export interface UserUpdateManyWithoutFavsInput {
  create?: UserCreateWithoutFavsInput[] | UserCreateWithoutFavsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFavsInput[]
    | UserUpdateWithWhereUniqueWithoutFavsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFavsInput[]
    | UserUpsertWithWhereUniqueWithoutFavsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutFavsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFavsDataInput;
}

export interface UserUpdateWithoutFavsDataInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
}

export interface UserUpsertWithWhereUniqueWithoutFavsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFavsDataInput;
  create: UserCreateWithoutFavsInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  isadmin?: String;
  isadmin_not?: String;
  isadmin_in?: String[] | String;
  isadmin_not_in?: String[] | String;
  isadmin_lt?: String;
  isadmin_lte?: String;
  isadmin_gt?: String;
  isadmin_gte?: String;
  isadmin_contains?: String;
  isadmin_not_contains?: String;
  isadmin_starts_with?: String;
  isadmin_not_starts_with?: String;
  isadmin_ends_with?: String;
  isadmin_not_ends_with?: String;
  issuper?: String;
  issuper_not?: String;
  issuper_in?: String[] | String;
  issuper_not_in?: String[] | String;
  issuper_lt?: String;
  issuper_lte?: String;
  issuper_gt?: String;
  issuper_gte?: String;
  issuper_contains?: String;
  issuper_not_contains?: String;
  issuper_starts_with?: String;
  issuper_not_starts_with?: String;
  issuper_ends_with?: String;
  issuper_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  payment?: String;
  payment_not?: String;
  payment_in?: String[] | String;
  payment_not_in?: String[] | String;
  payment_lt?: String;
  payment_lte?: String;
  payment_gt?: String;
  payment_gte?: String;
  payment_contains?: String;
  payment_not_contains?: String;
  payment_starts_with?: String;
  payment_not_starts_with?: String;
  payment_ends_with?: String;
  payment_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  plus?: String;
  plus_not?: String;
  plus_in?: String[] | String;
  plus_not_in?: String[] | String;
  plus_lt?: String;
  plus_lte?: String;
  plus_gt?: String;
  plus_gte?: String;
  plus_contains?: String;
  plus_not_contains?: String;
  plus_starts_with?: String;
  plus_not_starts_with?: String;
  plus_ends_with?: String;
  plus_not_ends_with?: String;
  reqadmin?: String;
  reqadmin_not?: String;
  reqadmin_in?: String[] | String;
  reqadmin_not_in?: String[] | String;
  reqadmin_lt?: String;
  reqadmin_lte?: String;
  reqadmin_gt?: String;
  reqadmin_gte?: String;
  reqadmin_contains?: String;
  reqadmin_not_contains?: String;
  reqadmin_starts_with?: String;
  reqadmin_not_starts_with?: String;
  reqadmin_ends_with?: String;
  reqadmin_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
}

export interface ProductUpdateManyInput {
  create?: ProductCreateInput[] | ProductCreateInput;
  update?:
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface ProductUpdateDataInput {
  productid?: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
  userdetail?: CartUpdateManyWithoutProductdetailInput;
}

export interface CartUpdateManyWithoutProductdetailInput {
  create?:
    | CartCreateWithoutProductdetailInput[]
    | CartCreateWithoutProductdetailInput;
  delete?: CartWhereUniqueInput[] | CartWhereUniqueInput;
  connect?: CartWhereUniqueInput[] | CartWhereUniqueInput;
  set?: CartWhereUniqueInput[] | CartWhereUniqueInput;
  disconnect?: CartWhereUniqueInput[] | CartWhereUniqueInput;
  update?:
    | CartUpdateWithWhereUniqueWithoutProductdetailInput[]
    | CartUpdateWithWhereUniqueWithoutProductdetailInput;
  upsert?:
    | CartUpsertWithWhereUniqueWithoutProductdetailInput[]
    | CartUpsertWithWhereUniqueWithoutProductdetailInput;
  deleteMany?: CartScalarWhereInput[] | CartScalarWhereInput;
  updateMany?:
    | CartUpdateManyWithWhereNestedInput[]
    | CartUpdateManyWithWhereNestedInput;
}

export interface CartUpdateWithWhereUniqueWithoutProductdetailInput {
  where: CartWhereUniqueInput;
  data: CartUpdateWithoutProductdetailDataInput;
}

export interface CartUpdateWithoutProductdetailDataInput {
  email?: String;
  mail?: String;
  productid?: String;
}

export interface CartUpsertWithWhereUniqueWithoutProductdetailInput {
  where: CartWhereUniqueInput;
  update: CartUpdateWithoutProductdetailDataInput;
  create: CartCreateWithoutProductdetailInput;
}

export interface CartScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mail?: String;
  mail_not?: String;
  mail_in?: String[] | String;
  mail_not_in?: String[] | String;
  mail_lt?: String;
  mail_lte?: String;
  mail_gt?: String;
  mail_gte?: String;
  mail_contains?: String;
  mail_not_contains?: String;
  mail_starts_with?: String;
  mail_not_starts_with?: String;
  mail_ends_with?: String;
  mail_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CartScalarWhereInput[] | CartScalarWhereInput;
  OR?: CartScalarWhereInput[] | CartScalarWhereInput;
  NOT?: CartScalarWhereInput[] | CartScalarWhereInput;
}

export interface CartUpdateManyWithWhereNestedInput {
  where: CartScalarWhereInput;
  data: CartUpdateManyDataInput;
}

export interface CartUpdateManyDataInput {
  email?: String;
  mail?: String;
  productid?: String;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface FavoriteUpdateManyMutationInput {
  email?: String;
  productid?: String;
}

export interface MigrationCreateInput {
  batch: Int;
  migration: String;
}

export interface MigrationUpdateInput {
  batch?: Int;
  migration?: String;
}

export interface MigrationUpdateManyMutationInput {
  batch?: Int;
  migration?: String;
}

export interface OrderCreateInput {
  email?: String;
  feedback?: String;
  productid?: String;
  rating?: String;
  remind?: String;
  return?: String;
  status?: String;
  transid?: String;
  owner: UserCreateOneInput;
  productdetail: ProductCreateOneInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
  favs?: FavoriteCreateManyWithoutOwnerInput;
}

export interface FavoriteCreateManyWithoutOwnerInput {
  create?: FavoriteCreateWithoutOwnerInput[] | FavoriteCreateWithoutOwnerInput;
  connect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
}

export interface FavoriteCreateWithoutOwnerInput {
  email?: String;
  productid?: String;
  productdetail?: ProductCreateManyInput;
}

export interface ProductCreateOneInput {
  create?: ProductCreateInput;
  connect?: ProductWhereUniqueInput;
}

export interface OrderUpdateInput {
  email?: String;
  feedback?: String;
  productid?: String;
  rating?: String;
  remind?: String;
  return?: String;
  status?: String;
  transid?: String;
  owner?: UserUpdateOneRequiredInput;
  productdetail?: ProductUpdateOneRequiredInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
  favs?: FavoriteUpdateManyWithoutOwnerInput;
}

export interface FavoriteUpdateManyWithoutOwnerInput {
  create?: FavoriteCreateWithoutOwnerInput[] | FavoriteCreateWithoutOwnerInput;
  delete?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  connect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  set?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  disconnect?: FavoriteWhereUniqueInput[] | FavoriteWhereUniqueInput;
  update?:
    | FavoriteUpdateWithWhereUniqueWithoutOwnerInput[]
    | FavoriteUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | FavoriteUpsertWithWhereUniqueWithoutOwnerInput[]
    | FavoriteUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  updateMany?:
    | FavoriteUpdateManyWithWhereNestedInput[]
    | FavoriteUpdateManyWithWhereNestedInput;
}

export interface FavoriteUpdateWithWhereUniqueWithoutOwnerInput {
  where: FavoriteWhereUniqueInput;
  data: FavoriteUpdateWithoutOwnerDataInput;
}

export interface FavoriteUpdateWithoutOwnerDataInput {
  email?: String;
  productid?: String;
  productdetail?: ProductUpdateManyInput;
}

export interface FavoriteUpsertWithWhereUniqueWithoutOwnerInput {
  where: FavoriteWhereUniqueInput;
  update: FavoriteUpdateWithoutOwnerDataInput;
  create: FavoriteCreateWithoutOwnerInput;
}

export interface FavoriteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  productid?: String;
  productid_not?: String;
  productid_in?: String[] | String;
  productid_not_in?: String[] | String;
  productid_lt?: String;
  productid_lte?: String;
  productid_gt?: String;
  productid_gte?: String;
  productid_contains?: String;
  productid_not_contains?: String;
  productid_starts_with?: String;
  productid_not_starts_with?: String;
  productid_ends_with?: String;
  productid_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  OR?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
  NOT?: FavoriteScalarWhereInput[] | FavoriteScalarWhereInput;
}

export interface FavoriteUpdateManyWithWhereNestedInput {
  where: FavoriteScalarWhereInput;
  data: FavoriteUpdateManyDataInput;
}

export interface FavoriteUpdateManyDataInput {
  email?: String;
  productid?: String;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ProductUpdateOneRequiredInput {
  create?: ProductCreateInput;
  update?: ProductUpdateDataInput;
  upsert?: ProductUpsertNestedInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface OrderUpdateManyMutationInput {
  email?: String;
  feedback?: String;
  productid?: String;
  rating?: String;
  remind?: String;
  return?: String;
  status?: String;
  transid?: String;
}

export interface OrdernotifCreateInput {
  email?: String;
  productid?: String;
  view?: String;
}

export interface OrdernotifUpdateInput {
  email?: String;
  productid?: String;
  view?: String;
}

export interface OrdernotifUpdateManyMutationInput {
  email?: String;
  productid?: String;
  view?: String;
}

export interface ProductUpdateInput {
  productid?: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
  userdetail?: CartUpdateManyWithoutProductdetailInput;
}

export interface ProductUpdateManyMutationInput {
  productid?: String;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
}

export interface ProjectCreateInput {
  description: String;
  name: String;
  userId: Int;
}

export interface ProjectUpdateInput {
  description?: String;
  name?: String;
  userId?: Int;
}

export interface ProjectUpdateManyMutationInput {
  description?: String;
  name?: String;
  userId?: Int;
}

export interface TokenCreateInput {
  refresh: ID_Input;
  access?: String;
}

export interface TokenUpdateInput {
  refresh?: ID_Input;
  access?: String;
}

export interface TokenUpdateManyMutationInput {
  refresh?: ID_Input;
  access?: String;
}

export interface UserUpdateInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
  favs?: FavoriteUpdateManyWithoutOwnerInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  address?: String;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
}

export interface ViewnotifCreateInput {
  email?: String;
  productid?: String;
}

export interface ViewnotifUpdateInput {
  email?: String;
  productid?: String;
}

export interface ViewnotifUpdateManyMutationInput {
  email?: String;
  productid?: String;
}

export interface CartSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CartWhereInput;
  AND?: CartSubscriptionWhereInput[] | CartSubscriptionWhereInput;
  OR?: CartSubscriptionWhereInput[] | CartSubscriptionWhereInput;
  NOT?: CartSubscriptionWhereInput[] | CartSubscriptionWhereInput;
}

export interface FailedJobSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FailedJobWhereInput;
  AND?: FailedJobSubscriptionWhereInput[] | FailedJobSubscriptionWhereInput;
  OR?: FailedJobSubscriptionWhereInput[] | FailedJobSubscriptionWhereInput;
  NOT?: FailedJobSubscriptionWhereInput[] | FailedJobSubscriptionWhereInput;
}

export interface FavoriteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FavoriteWhereInput;
  AND?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
  OR?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
  NOT?: FavoriteSubscriptionWhereInput[] | FavoriteSubscriptionWhereInput;
}

export interface MigrationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MigrationWhereInput;
  AND?: MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput;
  OR?: MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput;
  NOT?: MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface OrdernotifSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrdernotifWhereInput;
  AND?: OrdernotifSubscriptionWhereInput[] | OrdernotifSubscriptionWhereInput;
  OR?: OrdernotifSubscriptionWhereInput[] | OrdernotifSubscriptionWhereInput;
  NOT?: OrdernotifSubscriptionWhereInput[] | OrdernotifSubscriptionWhereInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectWhereInput;
  AND?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
  OR?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
  NOT?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
}

export interface TokenSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TokenWhereInput;
  AND?: TokenSubscriptionWhereInput[] | TokenSubscriptionWhereInput;
  OR?: TokenSubscriptionWhereInput[] | TokenSubscriptionWhereInput;
  NOT?: TokenSubscriptionWhereInput[] | TokenSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ViewnotifSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ViewnotifWhereInput;
  AND?: ViewnotifSubscriptionWhereInput[] | ViewnotifSubscriptionWhereInput;
  OR?: ViewnotifSubscriptionWhereInput[] | ViewnotifSubscriptionWhereInput;
  NOT?: ViewnotifSubscriptionWhereInput[] | ViewnotifSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Cart {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
  mail?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
}

export interface CartPromise extends Promise<Cart>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  mail: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  productdetail: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CartSubscription
  extends Promise<AsyncIterator<Cart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  mail: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  productdetail: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Product {
  id: ID_Output;
  productid: String;
  createdAt: DateTimeOutput;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  productid: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
  exclusive: () => Promise<String>;
  image: () => Promise<String>;
  name: () => Promise<String>;
  plusprice: () => Promise<String>;
  price: () => Promise<String>;
  pricedrop: () => Promise<String>;
  return: () => Promise<String>;
  seller: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  userdetail: <T = FragmentableArray<Cart>>(
    args?: {
      where?: CartWhereInput;
      orderBy?: CartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productid: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  desc: () => Promise<AsyncIterator<String>>;
  exclusive: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  plusprice: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  pricedrop: () => Promise<AsyncIterator<String>>;
  return: () => Promise<AsyncIterator<String>>;
  seller: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userdetail: <T = Promise<AsyncIterator<CartSubscription>>>(
    args?: {
      where?: CartWhereInput;
      orderBy?: CartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CartConnection {
  pageInfo: PageInfo;
  edges: CartEdge[];
}

export interface CartConnectionPromise
  extends Promise<CartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CartEdge>>() => T;
  aggregate: <T = AggregateCartPromise>() => T;
}

export interface CartConnectionSubscription
  extends Promise<AsyncIterator<CartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCartSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CartEdge {
  node: Cart;
  cursor: String;
}

export interface CartEdgePromise extends Promise<CartEdge>, Fragmentable {
  node: <T = CartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CartEdgeSubscription
  extends Promise<AsyncIterator<CartEdge>>,
    Fragmentable {
  node: <T = CartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCart {
  count: Int;
}

export interface AggregateCartPromise
  extends Promise<AggregateCart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCartSubscription
  extends Promise<AsyncIterator<AggregateCart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FailedJob {
  id: ID_Output;
  connection: String;
  exception: String;
  failedAt: DateTimeOutput;
  payload: String;
  queue: String;
}

export interface FailedJobPromise extends Promise<FailedJob>, Fragmentable {
  id: () => Promise<ID_Output>;
  connection: () => Promise<String>;
  exception: () => Promise<String>;
  failedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
  queue: () => Promise<String>;
}

export interface FailedJobSubscription
  extends Promise<AsyncIterator<FailedJob>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  connection: () => Promise<AsyncIterator<String>>;
  exception: () => Promise<AsyncIterator<String>>;
  failedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
  queue: () => Promise<AsyncIterator<String>>;
}

export interface FailedJobConnection {
  pageInfo: PageInfo;
  edges: FailedJobEdge[];
}

export interface FailedJobConnectionPromise
  extends Promise<FailedJobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FailedJobEdge>>() => T;
  aggregate: <T = AggregateFailedJobPromise>() => T;
}

export interface FailedJobConnectionSubscription
  extends Promise<AsyncIterator<FailedJobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FailedJobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFailedJobSubscription>() => T;
}

export interface FailedJobEdge {
  node: FailedJob;
  cursor: String;
}

export interface FailedJobEdgePromise
  extends Promise<FailedJobEdge>,
    Fragmentable {
  node: <T = FailedJobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FailedJobEdgeSubscription
  extends Promise<AsyncIterator<FailedJobEdge>>,
    Fragmentable {
  node: <T = FailedJobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFailedJob {
  count: Int;
}

export interface AggregateFailedJobPromise
  extends Promise<AggregateFailedJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFailedJobSubscription
  extends Promise<AsyncIterator<AggregateFailedJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Favorite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
}

export interface FavoritePromise extends Promise<Favorite>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  productdetail: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FavoriteSubscription
  extends Promise<AsyncIterator<Favorite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  productdetail: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface User {
  id: ID_Output;
  email?: String;
  address?: String;
  createdAt: DateTimeOutput;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  address: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  favorites: () => Promise<Json>;
  isadmin: () => Promise<String>;
  issuper: () => Promise<String>;
  items: () => Promise<Json>;
  name: () => Promise<String>;
  number: () => Promise<String>;
  password: () => Promise<String>;
  payment: () => Promise<String>;
  phone: () => Promise<String>;
  plus: () => Promise<String>;
  reqadmin: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  favs: <T = FragmentableArray<Favorite>>(
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  favorites: () => Promise<AsyncIterator<Json>>;
  isadmin: () => Promise<AsyncIterator<String>>;
  issuper: () => Promise<AsyncIterator<String>>;
  items: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  payment: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  plus: () => Promise<AsyncIterator<String>>;
  reqadmin: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  favs: <T = Promise<AsyncIterator<FavoriteSubscription>>>(
    args?: {
      where?: FavoriteWhereInput;
      orderBy?: FavoriteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FavoriteConnection {
  pageInfo: PageInfo;
  edges: FavoriteEdge[];
}

export interface FavoriteConnectionPromise
  extends Promise<FavoriteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FavoriteEdge>>() => T;
  aggregate: <T = AggregateFavoritePromise>() => T;
}

export interface FavoriteConnectionSubscription
  extends Promise<AsyncIterator<FavoriteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FavoriteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFavoriteSubscription>() => T;
}

export interface FavoriteEdge {
  node: Favorite;
  cursor: String;
}

export interface FavoriteEdgePromise
  extends Promise<FavoriteEdge>,
    Fragmentable {
  node: <T = FavoritePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FavoriteEdgeSubscription
  extends Promise<AsyncIterator<FavoriteEdge>>,
    Fragmentable {
  node: <T = FavoriteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFavorite {
  count: Int;
}

export interface AggregateFavoritePromise
  extends Promise<AggregateFavorite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFavoriteSubscription
  extends Promise<AsyncIterator<AggregateFavorite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Migration {
  id: ID_Output;
  batch: Int;
  migration: String;
}

export interface MigrationPromise extends Promise<Migration>, Fragmentable {
  id: () => Promise<ID_Output>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
}

export interface MigrationSubscription
  extends Promise<AsyncIterator<Migration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration: () => Promise<AsyncIterator<String>>;
}

export interface MigrationConnection {
  pageInfo: PageInfo;
  edges: MigrationEdge[];
}

export interface MigrationConnectionPromise
  extends Promise<MigrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MigrationEdge>>() => T;
  aggregate: <T = AggregateMigrationPromise>() => T;
}

export interface MigrationConnectionSubscription
  extends Promise<AsyncIterator<MigrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MigrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMigrationSubscription>() => T;
}

export interface MigrationEdge {
  node: Migration;
  cursor: String;
}

export interface MigrationEdgePromise
  extends Promise<MigrationEdge>,
    Fragmentable {
  node: <T = MigrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MigrationEdgeSubscription
  extends Promise<AsyncIterator<MigrationEdge>>,
    Fragmentable {
  node: <T = MigrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMigration {
  count: Int;
}

export interface AggregateMigrationPromise
  extends Promise<AggregateMigration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMigrationSubscription
  extends Promise<AsyncIterator<AggregateMigration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  feedback?: String;
  productid?: String;
  rating?: String;
  remind?: String;
  return?: String;
  status?: String;
  transid?: String;
  updatedAt: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  feedback: () => Promise<String>;
  productid: () => Promise<String>;
  rating: () => Promise<String>;
  remind: () => Promise<String>;
  return: () => Promise<String>;
  status: () => Promise<String>;
  transid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  productdetail: <T = ProductPromise>() => T;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  feedback: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<String>>;
  remind: () => Promise<AsyncIterator<String>>;
  return: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  transid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  productdetail: <T = ProductSubscription>() => T;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Ordernotif {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
  view?: String;
}

export interface OrdernotifPromise extends Promise<Ordernotif>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  view: () => Promise<String>;
}

export interface OrdernotifSubscription
  extends Promise<AsyncIterator<Ordernotif>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  view: () => Promise<AsyncIterator<String>>;
}

export interface OrdernotifConnection {
  pageInfo: PageInfo;
  edges: OrdernotifEdge[];
}

export interface OrdernotifConnectionPromise
  extends Promise<OrdernotifConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrdernotifEdge>>() => T;
  aggregate: <T = AggregateOrdernotifPromise>() => T;
}

export interface OrdernotifConnectionSubscription
  extends Promise<AsyncIterator<OrdernotifConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrdernotifEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrdernotifSubscription>() => T;
}

export interface OrdernotifEdge {
  node: Ordernotif;
  cursor: String;
}

export interface OrdernotifEdgePromise
  extends Promise<OrdernotifEdge>,
    Fragmentable {
  node: <T = OrdernotifPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrdernotifEdgeSubscription
  extends Promise<AsyncIterator<OrdernotifEdge>>,
    Fragmentable {
  node: <T = OrdernotifSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrdernotif {
  count: Int;
}

export interface AggregateOrdernotifPromise
  extends Promise<AggregateOrdernotif>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrdernotifSubscription
  extends Promise<AsyncIterator<AggregateOrdernotif>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Project {
  id: ID_Output;
  createdAt: DateTimeOutput;
  description: String;
  name: String;
  updatedAt: DateTimeOutput;
  userId: Int;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<Int>;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Token {
  refresh: ID_Output;
  access?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TokenPromise extends Promise<Token>, Fragmentable {
  refresh: () => Promise<ID_Output>;
  access: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TokenSubscription
  extends Promise<AsyncIterator<Token>>,
    Fragmentable {
  refresh: () => Promise<AsyncIterator<ID_Output>>;
  access: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TokenConnection {
  pageInfo: PageInfo;
  edges: TokenEdge[];
}

export interface TokenConnectionPromise
  extends Promise<TokenConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TokenEdge>>() => T;
  aggregate: <T = AggregateTokenPromise>() => T;
}

export interface TokenConnectionSubscription
  extends Promise<AsyncIterator<TokenConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TokenEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTokenSubscription>() => T;
}

export interface TokenEdge {
  node: Token;
  cursor: String;
}

export interface TokenEdgePromise extends Promise<TokenEdge>, Fragmentable {
  node: <T = TokenPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TokenEdgeSubscription
  extends Promise<AsyncIterator<TokenEdge>>,
    Fragmentable {
  node: <T = TokenSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateToken {
  count: Int;
}

export interface AggregateTokenPromise
  extends Promise<AggregateToken>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTokenSubscription
  extends Promise<AsyncIterator<AggregateToken>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Viewnotif {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
}

export interface ViewnotifPromise extends Promise<Viewnotif>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ViewnotifSubscription
  extends Promise<AsyncIterator<Viewnotif>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ViewnotifConnection {
  pageInfo: PageInfo;
  edges: ViewnotifEdge[];
}

export interface ViewnotifConnectionPromise
  extends Promise<ViewnotifConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ViewnotifEdge>>() => T;
  aggregate: <T = AggregateViewnotifPromise>() => T;
}

export interface ViewnotifConnectionSubscription
  extends Promise<AsyncIterator<ViewnotifConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewnotifEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewnotifSubscription>() => T;
}

export interface ViewnotifEdge {
  node: Viewnotif;
  cursor: String;
}

export interface ViewnotifEdgePromise
  extends Promise<ViewnotifEdge>,
    Fragmentable {
  node: <T = ViewnotifPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ViewnotifEdgeSubscription
  extends Promise<AsyncIterator<ViewnotifEdge>>,
    Fragmentable {
  node: <T = ViewnotifSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateViewnotif {
  count: Int;
}

export interface AggregateViewnotifPromise
  extends Promise<AggregateViewnotif>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewnotifSubscription
  extends Promise<AsyncIterator<AggregateViewnotif>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CartSubscriptionPayload {
  mutation: MutationType;
  node: Cart;
  updatedFields: String[];
  previousValues: CartPreviousValues;
}

export interface CartSubscriptionPayloadPromise
  extends Promise<CartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CartPreviousValuesPromise>() => T;
}

export interface CartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CartPreviousValuesSubscription>() => T;
}

export interface CartPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
  mail?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
}

export interface CartPreviousValuesPromise
  extends Promise<CartPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  mail: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CartPreviousValuesSubscription
  extends Promise<AsyncIterator<CartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  mail: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FailedJobSubscriptionPayload {
  mutation: MutationType;
  node: FailedJob;
  updatedFields: String[];
  previousValues: FailedJobPreviousValues;
}

export interface FailedJobSubscriptionPayloadPromise
  extends Promise<FailedJobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FailedJobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FailedJobPreviousValuesPromise>() => T;
}

export interface FailedJobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FailedJobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FailedJobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FailedJobPreviousValuesSubscription>() => T;
}

export interface FailedJobPreviousValues {
  id: ID_Output;
  connection: String;
  exception: String;
  failedAt: DateTimeOutput;
  payload: String;
  queue: String;
}

export interface FailedJobPreviousValuesPromise
  extends Promise<FailedJobPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  connection: () => Promise<String>;
  exception: () => Promise<String>;
  failedAt: () => Promise<DateTimeOutput>;
  payload: () => Promise<String>;
  queue: () => Promise<String>;
}

export interface FailedJobPreviousValuesSubscription
  extends Promise<AsyncIterator<FailedJobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  connection: () => Promise<AsyncIterator<String>>;
  exception: () => Promise<AsyncIterator<String>>;
  failedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payload: () => Promise<AsyncIterator<String>>;
  queue: () => Promise<AsyncIterator<String>>;
}

export interface FavoriteSubscriptionPayload {
  mutation: MutationType;
  node: Favorite;
  updatedFields: String[];
  previousValues: FavoritePreviousValues;
}

export interface FavoriteSubscriptionPayloadPromise
  extends Promise<FavoriteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FavoritePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FavoritePreviousValuesPromise>() => T;
}

export interface FavoriteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FavoriteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FavoriteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FavoritePreviousValuesSubscription>() => T;
}

export interface FavoritePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
}

export interface FavoritePreviousValuesPromise
  extends Promise<FavoritePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FavoritePreviousValuesSubscription
  extends Promise<AsyncIterator<FavoritePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MigrationSubscriptionPayload {
  mutation: MutationType;
  node: Migration;
  updatedFields: String[];
  previousValues: MigrationPreviousValues;
}

export interface MigrationSubscriptionPayloadPromise
  extends Promise<MigrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MigrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MigrationPreviousValuesPromise>() => T;
}

export interface MigrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MigrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MigrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MigrationPreviousValuesSubscription>() => T;
}

export interface MigrationPreviousValues {
  id: ID_Output;
  batch: Int;
  migration: String;
}

export interface MigrationPreviousValuesPromise
  extends Promise<MigrationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
}

export interface MigrationPreviousValuesSubscription
  extends Promise<AsyncIterator<MigrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration: () => Promise<AsyncIterator<String>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  feedback?: String;
  productid?: String;
  rating?: String;
  remind?: String;
  return?: String;
  status?: String;
  transid?: String;
  updatedAt: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  feedback: () => Promise<String>;
  productid: () => Promise<String>;
  rating: () => Promise<String>;
  remind: () => Promise<String>;
  return: () => Promise<String>;
  status: () => Promise<String>;
  transid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  feedback: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<String>>;
  remind: () => Promise<AsyncIterator<String>>;
  return: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  transid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrdernotifSubscriptionPayload {
  mutation: MutationType;
  node: Ordernotif;
  updatedFields: String[];
  previousValues: OrdernotifPreviousValues;
}

export interface OrdernotifSubscriptionPayloadPromise
  extends Promise<OrdernotifSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrdernotifPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrdernotifPreviousValuesPromise>() => T;
}

export interface OrdernotifSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrdernotifSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrdernotifSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrdernotifPreviousValuesSubscription>() => T;
}

export interface OrdernotifPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
  view?: String;
}

export interface OrdernotifPreviousValuesPromise
  extends Promise<OrdernotifPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  view: () => Promise<String>;
}

export interface OrdernotifPreviousValuesSubscription
  extends Promise<AsyncIterator<OrdernotifPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  view: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  productid: String;
  createdAt: DateTimeOutput;
  desc?: String;
  exclusive?: String;
  image?: String;
  name?: String;
  plusprice?: String;
  price?: String;
  pricedrop?: String;
  return?: String;
  seller?: String;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  productid: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
  exclusive: () => Promise<String>;
  image: () => Promise<String>;
  name: () => Promise<String>;
  plusprice: () => Promise<String>;
  price: () => Promise<String>;
  pricedrop: () => Promise<String>;
  return: () => Promise<String>;
  seller: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  productid: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  desc: () => Promise<AsyncIterator<String>>;
  exclusive: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  plusprice: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  pricedrop: () => Promise<AsyncIterator<String>>;
  return: () => Promise<AsyncIterator<String>>;
  seller: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  description: String;
  name: String;
  updatedAt: DateTimeOutput;
  userId: Int;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<Int>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<Int>>;
}

export interface TokenSubscriptionPayload {
  mutation: MutationType;
  node: Token;
  updatedFields: String[];
  previousValues: TokenPreviousValues;
}

export interface TokenSubscriptionPayloadPromise
  extends Promise<TokenSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TokenPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TokenPreviousValuesPromise>() => T;
}

export interface TokenSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TokenSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TokenSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TokenPreviousValuesSubscription>() => T;
}

export interface TokenPreviousValues {
  refresh: ID_Output;
  access?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TokenPreviousValuesPromise
  extends Promise<TokenPreviousValues>,
    Fragmentable {
  refresh: () => Promise<ID_Output>;
  access: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TokenPreviousValuesSubscription
  extends Promise<AsyncIterator<TokenPreviousValues>>,
    Fragmentable {
  refresh: () => Promise<AsyncIterator<ID_Output>>;
  access: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  address?: String;
  createdAt: DateTimeOutput;
  favorites?: Json;
  isadmin?: String;
  issuper?: String;
  items?: Json;
  name?: String;
  number?: String;
  password?: String;
  payment?: String;
  phone?: String;
  plus?: String;
  reqadmin?: String;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  address: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  favorites: () => Promise<Json>;
  isadmin: () => Promise<String>;
  issuper: () => Promise<String>;
  items: () => Promise<Json>;
  name: () => Promise<String>;
  number: () => Promise<String>;
  password: () => Promise<String>;
  payment: () => Promise<String>;
  phone: () => Promise<String>;
  plus: () => Promise<String>;
  reqadmin: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  favorites: () => Promise<AsyncIterator<Json>>;
  isadmin: () => Promise<AsyncIterator<String>>;
  issuper: () => Promise<AsyncIterator<String>>;
  items: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  payment: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  plus: () => Promise<AsyncIterator<String>>;
  reqadmin: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ViewnotifSubscriptionPayload {
  mutation: MutationType;
  node: Viewnotif;
  updatedFields: String[];
  previousValues: ViewnotifPreviousValues;
}

export interface ViewnotifSubscriptionPayloadPromise
  extends Promise<ViewnotifSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ViewnotifPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewnotifPreviousValuesPromise>() => T;
}

export interface ViewnotifSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewnotifSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewnotifSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewnotifPreviousValuesSubscription>() => T;
}

export interface ViewnotifPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email?: String;
  productid?: String;
  updatedAt: DateTimeOutput;
}

export interface ViewnotifPreviousValuesPromise
  extends Promise<ViewnotifPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  productid: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ViewnotifPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewnotifPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  productid: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Cart",
    embedded: false
  },
  {
    name: "FailedJob",
    embedded: false
  },
  {
    name: "Favorite",
    embedded: false
  },
  {
    name: "Migration",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Ordernotif",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Token",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Viewnotif",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
